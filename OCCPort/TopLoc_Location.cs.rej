diff a/OCCPort/TopLoc_Location.cs b/OCCPort/TopLoc_Location.cs	(rejected hunks)
@@ -10,6 +10,7 @@ namespace OCCPort
 
 	public class TopLoc_Location
 	{
+
 		public TopLoc_Location()
 		{
 			myItems = new TopLoc_SListOfItemLocation();
@@ -22,6 +23,10 @@ namespace OCCPort
 		}
 
 		public TopLoc_SListOfItemLocation myItems;
+		public void Clear()
+		{
+			myItems.Clear();
+		}
 
 		internal TopLoc_Location Inverted()
 		{
@@ -57,5 +62,59 @@ namespace OCCPort
 				return myItems.Value().myTrsf;
 
 		}
+
+		public TopLoc_Location Predivided(TopLoc_Location Other)
+
+		{
+			return Other.Inverted().Multiplied(this);
+		}
+
+		private TopLoc_Location Multiplied(TopLoc_Location Other)
+		{
+			// prepend the chain Other in front of this
+			// cancelling null exponents
+
+			if (IsIdentity()) return Other;
+			if (Other.IsIdentity()) return this;
+
+			// prepend the queue of Other
+			TopLoc_Location result = Multiplied(Other.NextLocation());
+			// does the head of Other cancel the head of result
+
+			int p = Other.FirstPower();
+			if (!result.IsIdentity())
+			{
+				if (Other.FirstDatum() == result.FirstDatum())
+				{
+					p += result.FirstPower();
+					result.myItems.ToTail();
+				}
+			}
+			if (p != 0)
+				result.myItems.Construct(new TopLoc_ItemLocation(Other.FirstDatum(), p));
+			return result;
+
+		}
+
+		private TopLoc_Location NextLocation()
+		{
+			throw new NotImplementedException();
+		}
+
+		private int FirstPower()
+		{
+			throw new NotImplementedException();
+		}
+
+		private TopLoc_Datum3D FirstDatum()
+		{
+			throw new NotImplementedException();
+		}
+
+		internal TopLoc_Location Clone()
+		{
+			return (TopLoc_Location)this.MemberwiseClone();
+			
+		}
 	}
 }
\ No newline at end of file

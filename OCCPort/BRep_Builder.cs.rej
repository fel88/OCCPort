diff a/OCCPort/BRep_Builder.cs b/OCCPort/BRep_Builder.cs	(rejected hunks)
@@ -26,129 +26,35 @@ namespace OCCPort
 	{
 
 
-        //! Add the Shape C in the Shape S.
-        //! Exceptions
-        //! - TopoDS_FrozenShape if S is not free and cannot be modified.
-        //! - TopoDS__UnCompatibleShapes if S and C are not compatible.
-        public void Add(TopoDS_Shape aShape, TopoDS_Shape aComponent)
-        {
-
-            //=======================================================================
-            //function : Add
-            //purpose  : insert aComponent in aShape
-            //=======================================================================
-
-
-
-            // From now the Component cannot be edited
-            aComponent.TShape().Free(false);
-
-            // Note that freezing aComponent before testing if aShape is free
-            // prevents from self-insertion
-            // but aShape will be frozen when the Exception is raised
-            if (aShape.Free())
-            {
-                uint[] aTb =                 {
-      //COMPOUND to:
-      (1<<((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)),
-      //COMPSOLID to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)),
-      //SOLID to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPSOLID)),
-      //SHELL to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_SOLID)),
-      //FACE to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_SHELL)),
-      //WIRE to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_FACE)),
-      //EDGE to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_SOLID)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_WIRE)),
-      //VERTEX to:
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_COMPOUND)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_SOLID)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_FACE)) |
-      (1 << ((int)TopAbs_ShapeEnum.TopAbs_EDGE)),
-      //SHAPE to:
-      0
-                  };
-                //
-                uint iC = (uint)aComponent.ShapeType();
-                int iS = (int)aShape.ShapeType();
-                //
-                if ((aTb[iC] & (1 << iS)) != 0)
-                {
-                    TopoDS_ListOfShape L = aShape.TShape().myShapes;
-                    L.Append(aComponent);
-                    TopoDS_Shape S = L.Last();
-                    //
-                    // compute the relative Orientation
-                    if (aShape.Orientation() == TopAbs_Orientation.TopAbs_REVERSED)
-                        S.Reverse();
-                    //
-                    // and the Relative Location
-                    TopLoc_Location aLoc = aShape.Location();
-                    if (!aLoc.IsIdentity())
-                        S.Move(aLoc.Inverted(), false);
-                    //
-                    // Set the TShape as modified.
-                    aShape.TShape().Modified(true);
-                }
-                else
-                {
-                    throw new TopoDS_UnCompatibleShapes("TopoDS_Builder::Add");
-                }
-            }
-            else
-            {
-                throw new TopoDS_FrozenShape("TopoDS_Builder::Add");
-            }
-        }
 		
-        internal void Add(TopoDS_Edge e, TopoDS_Vertex vV)
-        {
-            throw new NotImplementedException();
-        }
 
-        internal void Add(TopoDS_Wire w, TopoDS_Edge eE)
-        {
-            throw new NotImplementedException();
-        }
+		public void MakeEdge(TopoDS_Edge E,
 
-        internal void Add(TopoDS_Face f, TopoDS_Wire w)
+									Geom_Curve C,
+									double Tol)
 		{
-            throw new NotImplementedException();
+			MakeEdge(E);
+			UpdateEdge(E, C, new TopLoc_Location(), Tol);
 		}
 
-        internal void MakeEdge(TopoDS_Edge E, Geom_Curve C, double Tol)
-        {
-            throw new NotImplementedException();
-        }
+
 		public void MakeEdge(TopoDS_Edge E)
 		{
 			BRep_TEdge TE = new BRep_TEdge();
-            if (E != null && E.Locked())
+			if (!E.IsNull() && E.Locked())
 			{
 				throw new TopoDS_LockedShape("BRep_Builder::MakeEdge");
 			}
 			MakeShape(E, TE);
 		}
 
-        private void MakeShape(TopoDS_Edge e, BRep_TEdge tE)
-        {
-            throw new NotImplementedException();
-        }
+
 
 		internal void MakeFace(TopoDS_Face F, Geom_Surface S,
 					double Tol)
 		{
 			BRep_TFace TF = new BRep_TFace();
-            if (F != null && F.Locked())
+			if (!F.IsNull() && F.Locked())
 			{
 				throw new TopoDS_LockedShape("BRep_Builder::MakeFace");
 			}
@@ -157,10 +63,6 @@ namespace OCCPort
 			MakeShape(F, TF);
 		}
 
-        private void MakeShape(TopoDS_Face f, BRep_TFace tF)
-        {
-            throw new NotImplementedException();
-        }
 
 		public void MakeFace(TopoDS_Face F)
 		{
@@ -174,6 +76,76 @@ namespace OCCPort
 			throw new NotImplementedException();
 		}
 
+		public void UpdateEdge(TopoDS_Edge E,
+								Geom_Curve C,
+								TopLoc_Location L,
+								double Tol)
+		{
+			BRep_TEdge TE = E.TShape() as BRep_TEdge;
+			if (TE.Locked())
+			{
+				throw new TopoDS_LockedShape("BRep_Builder::UpdateEdge");
+			}
+			TopLoc_Location l = L.Predivided(E.Location()).Clone();
+
+			UpdateCurves(TE.ChangeCurves(), C, l);
+
+			TE.UpdateTolerance(Tol);
+			TE.Modified(true);
+		}
+
+		private void UpdateCurves(BRep_ListOfCurveRepresentation lcr, Geom_Curve C, TopLoc_Location L)
+		{
+			BRep_ListIteratorOfListOfCurveRepresentation itcr = new BRep_ListIteratorOfListOfCurveRepresentation(lcr);
+			BRep_GCurve GC = null;
+			double f = 0.0, l = 0.0;
+
+			while (itcr.More())
+			{
+				if (itcr.Value() is BRep_GCurve bb)
+				{
+					GC = bb;
+				}
+				//GC = Handle(BRep_GCurve)::DownCast(itcr.Value());
+				if (GC != null)
+				{
+					GC.Range(f, l);
+					if (GC.IsCurve3D()) break;
+
+				}
+				itcr.Next();
+			}
+
+			if (itcr.More())
+			{
+				itcr.Value().Curve3D(C);
+				itcr.Value().Location(L);
+			}
+			else
+			{
+				BRep_Curve3D C3d = new BRep_Curve3D(C, L);
+				// test if there is already a range
+				if (GC != null)
+				{
+					C3d.SetRange(f, l);
+				}
+				lcr.Append(C3d);
+			}
+		}
+		public void UpdateVertex(TopoDS_Vertex V,
+								 gp_Pnt P,
+								 double Tol)
+		{
+			BRep_TVertex TV = V.TShape() as BRep_TVertex;
+			if (TV.Locked())
+			{
+				throw new TopoDS_LockedShape("BRep_Builder::UpdateVertex");
+			}
+			TV.Pnt(P.Transformed(V.Location().Inverted().Transformation()));
+			TV.UpdateTolerance(Tol);
+			TV.Modified(true);
+		}
+
 		internal void UpdateVertex(TopoDS_Vertex V,
 							double Par, TopoDS_Edge E, double F, double Tol)
 		{
@@ -185,5 +157,17 @@ namespace OCCPort
 		{
 			throw new NotImplementedException();
 		}
+		public void MakeVertex(TopoDS_Vertex V)
+		{
+			BRep_TVertex TV = new BRep_TVertex();
+			MakeShape(V, TV);
+		}
+
+		internal void MakeVertex(TopoDS_Vertex V, gp_Pnt P, double Tol)
+		{
+			MakeVertex(V);
+			UpdateVertex(V, P, Tol);
+
+		}
 	}
 }
\ No newline at end of file
